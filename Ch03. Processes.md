- 프로세스란? 실행되려고 메모리에 올라온 프로그램
	- 대부분 시스템의 일 단위
- 시스템은 프로세스의 집합
- 현대 OS는 쓰레드 여러개를 가지고 있음
	- 쓰레드 : 제어하는개수, 쓰레드 하나면 코어도 하나
	- 프로세싱 코어가 여러개면 쓰레드는 병렬로 실행될 수 있음
- 옛날에는 한번에 한 프로그램만 실행할 수 있었고
- 이 프로그램이 시스템의 모든 통제권을 갖고 모든 자원에 접근 가능했습니다
- 요즘은 여러 프로그램들이 동시에 로드/실행되져
	- 더 견고한 제어/구획화 필요

# 3.1 Process Concept

- 초기 컴퓨터 : 일을 일괄처리하는 시스템
- 나중 : task를 실행하는 시분할 시스템
- 싱글 유저 시스템에서도 한번에 여러 프로그램을 실행
	- 한번에 한 프로그램만 실행한다고 해도, OS는 메모리관리같은 걸 해줘야함

- 현대에선 프로세스라고 하지만, job이라고도 할 수 있음

 - 프로세스란? 실행중인 프로그램
 ![|300](https://i.imgur.com/hsW76rI.png)

 - 프로세스가 메모리에 있는 상태의 레이아웃은 이렇게 나뉨
	 - 텍스트 섹션 : 실행 코드
	 - 데이터 섹션 : 전역 변수
	 - 힙 섹션 : 동적할당
	 - 스택 섹션 : 함수, 지역변수, 리턴값
- 텍스트, 데이터 섹션의 사이즈는 고정임
- 스택, 힙 섹션은 계속 변함
	- 함수가 불러와지면 관련된 활동 기록은 스택에 푸시됨
	- 함수가 끝나서 리턴되면 스택에서 팝됨
	- 힙도 메모리가 동적할당되면 커지고, 시스템으로 리턴되면 줄음
- 서로 방향으로 커지니까, OS가 얘네끼리 서로 안 겹치게 해줘야겠죠

- 프로그램 자체로는 프로세스가 아니고, 실행되어서 메모리에 올라가야 프로세스임
- 프로그램 : 디스크에 저장된, 명령어 리스트를 포함하는 실행 가능한 파일
- 프로세스 : 다음 실행 명령어를 나타내는 프로그램 카운터과 관련 자원집합이 있음

- 두 프로세스가 동일한 프로그램과 연관되더라도, 두 개의 독립된 실행 순서로 간주됨
![|400](https://i.imgur.com/kkqMo2x.png)

- 같은 프로그램이지만 여러개의 프로세스, 독립된 실행 순서!
- 텍스트 섹션만 같고, 나머지는 다른거임!!!
- 프로세스가 실행 중에 새끼프로세스를 생성하죠
- 프로세스는 다른 코드의 실행환경이 되기도 함 (자바 프로그래밍)


- 프로세스가 실행되면 이렇게 상태가 바뀝니다
 ![](https://i.imgur.com/cIWvOvD.png)
- new : 프로세스가 만들어졌을 때 (메모리에 올라감)
- ready : 프로세스가 프로세서에 할당되기를 대기
- running : instruction이 만들어지는 중
- waiting : 프로세스가 어떤 이벤트가 발생하기를 기다림
- terminated : 프로세스가 실행 종료
- 오직 하나의 프로세스만이 프로세스 코어에 돌아갈 수 잇따
- 여러 프로세스는 ready/waiting이 반복된다

- PCB 
	- 각각의 프로세스는 OS에서 PCB의 형태로 나타남
	- 특정 프로세스 관련 정보들을 포함함
	- state (뉴 레디 러닝 웨이팅 종료)
	- PC
	- CPU 레지스터 (interrupt 발생하면 PC와 함께 상태 정보 저장)
	- CPU 스케쥴링 정보(우선순위, 포인터, 파라미터)
	- 메모리 관리 정보
	- I/O status 정보 (프로세스에 할당된 I/O 디바이스)
	- accounting info (얼마나 CPU랑 시간을 잡아먹고  등등)
- 즉, PCB는 프로세스의 실행/재실행을 위해 필요한 모든 정보의 저장소!


- 싱글쓰레드
	- 한 프로세스가 한 실행 쓰레드를 가짐
	- 싱글 쓰레드 제어는 한번에 하나의 task만 실행 가능
	- 예를 들어서 문자입력/철자검사를 동시에 못함

- 최근에는 한 프로세스가 여러 실행 thread를 갖는 멀티쓰레드가 많음
	- 이러면 한번에 여러 task 실행 가능
	- 멀티코어라면, 여러 쓰레드가 병렬 로 실행 됨
	- 이 경우 쓰레드마다 PCB를 가짐

# 3.2 Process Scheduling

- 멀티프로그래밍의 목표
	- 항상 프로세스들이 실행되도록 해서 CPU 이용률 최대화
- time sharing의 목표
	- 프로세스 사이에서 CPU코어를 자주 스위치해서, 유저와 프로그램이 interact 가능
- 이걸 하려면.. 
	- core에서 프로그램을 실행하기 위해 실행 가능한 프로세스를 하나 고름
	- 각 core는 한번에 하나의 프로세스만 실행
- 싱글코어 시스템 : 한번에 하나만
- 멀티코어 시스템 : 한번에 여러개
- 코어개수 < 프로세스 개수라면
	- 넘치는 프로세스들은 코어가 놀 때까지 기다려야 함
- Degree of multiprogramming : 현재 메모리에 있는 프로세스 수
	- 정도가 높아지면 부하 걸려서 사용률이 갑자기 낮아지므로 ,OS가 잘 관리

- 멀티프로그래밍와 time sharing의 목표를 잘 균형있게 맞춰야함
	- 프로세스의 일반적 동작을 고려해서
	- I/O bound process : I/O에 더 많은 시간 소비
	- CPU bound process : 계싼에 더많은 시간 소비

- 프로세스가 시스템에 진입하면, 레디큐에 삽입된 후 코어에서 실행되기를 대기함
	- 이 때, 연결리스트의 형태로 저장
	![](https://i.imgur.com/XHKo2MW.png)

	- 큐의 헤드는 첫 PCB 포인터를 가짐, 각 PCB는 다음 PCB에 대한 포인터를 가짐
- Ready Queue 말고 Wait Queue라는 것도 있음
	- 프로세스에 CPU가 할당되면
	- 한참 실행되었다가 결국 종료되거나
	- 인터럽트되거나
	- wait를 함  (특정 이벤트에 대해서)
	- 그 이벤트를 wait하는 프로세스는 wait queue 삽입
- Queueing diagram
	- 프로세스 스케쥴링의 일반적인 표현
	- 레디큐랑 wait queue가 있음
	- ![](https://i.imgur.com/BWOQwrT.png)

- 프로세스는 종료될때까지 이 사이클을 반복함
- 종료되면 모든 큐에서 제거되고, PCB와 자원이 해제됨

- CPU 스케쥴링
	- 프로세스는 ready랑 wait queue 사이에서 와리가리함
	- CPU 스케쥴러의 역할
		- 레디큐에서 하나의 프로세스를 선택하고 CPU 코어 할당
		- 잠깐 CPU 실행 후 I/O 대기
		- 오래동안 필요해도 장시간 할당은 X
		- CPU를 뺏어서 다른 프로세스에게 스케쥴
	- Swapping
		- 메모리가 과부화되었을때, swapping으로 degree 낮춤
		- 나중에 괜찮아지면 다시 프로세스를 불러와라
		- 다시 불러온 애는 중단된 곳에서 계속 실행
		- 메모리가 초과 사용되어서 해제될 때만 필요
	- Context switch
		![](https://i.imgur.com/7foq1zx.png)

		- 인터럽트는 OS가 현재 task로부터 CPU 코어를 뺏어 커널 루틴 실행하게 함
		- 인터럽트 발생하면, CPU코어에서 실행 중인 프로세스의 현재 context를 저장
		- 인터럽트 처리가 끝나면 해당 context 복원 (일시중단 후 실행)
		- 이 context는 PCB에 있음
		- 이렇게 다른 프로세스로 CPU 코어를 스위치 하는 것 : context switch
	- Context-switch 하는 동안 시스템은 다른 걸 못해서 시간낭비임 (오버헤드)
	- 스위칭 속도는 그때그떄 다른데, 하드웨어가 얼마나 받쳐주느냐에 따라 크게 달라짐 (레지스터)

# Ch3.3 Operations in Process

- 프로세스는 동시에 수행되고, 동적으로 생성/삭제 됨
- 실행 중에, 프로세스는 새로운 프로세스를 생성!
	- 생성하는 놈 : 부모프로세스
	- 새로생긴놈 : 자식프로세스

- Process identifier (pid) : 프로세스마다 부여되는 고유한 번호
	- 커널 내에서 다양한 프로세스의 속성의 접근하기 위한 인덱스로 씀
		- 예) kill -9 4471(pid)

- UNIX계열에선 ps(process state) 커맨드로 프로세스를 쫘악~~
![](https://i.imgur.com/9Mn8zb0.png)
PPID가 2면 PID 2인애가 부모라는 거죠
- pstree면 이걸 트리형태로 볼 수있어요

- pid=1인 프로세스를 systemd 프로세스라고 하는데
	- 부팅되면 처음으로 생성되는 프로세스고, 다른 애들의 부모입니다

- 프로세스와 그 자식관의 관계
	- 생성된 자식은 자원을 필요로 합니다
		- OS로부터 직접 자원 받기
		- 부모 프로세스 자원의 부분집합
			- 자식들 간의 자원을 분할하거나, 자식들과 자원을 공유
			- 이러면 한 프로세스가 애기를 너무 많이 까서 과부화되는게 막힘

- 자식 프로세스에 필요한 데이터는 어케 전달?
	- 부모가 자식에게 초기화 데이터를 전달함 (파일명 등)
	- 아니면 OS가 자식에게 자원을 전달함

- 자식 프로세스가 생성되면, 부모/자식은 병행 실행되는거임
- 부모는 자식이 종료도리 떄까지 기다려야겠지

- 주소 공간은 두가지 경우
	- 자식이 부모 메모리를 복제해서, 둘다 동일한 프로그램/데이터 가짐
	- 자식이 자신에게 로드되는 새로운 프로그램 가짐


- UNIX의 예
	- 각각은 pid를 가지겠죠
	- 자식은 fork() 라는 시스템콜로 생성됨 (부모의 주소공간 복사본)
	- 부모-자식간 통신이 쉬움
	- 자식 프로세스에 대해, fork()의 리턴코드는 0 (정상처리라면)
	- 자식의 pid는 부모에게 리턴됨 
	- 자식 pid = 0 , 부모 pid = 자식의 pid
	- ![](https://i.imgur.com/PGUL8fG.png)


- fork() 시스템 콜 후에, 자식 프로세스가 exec()를 시스템콜해서 메모리공간을 새 프로그램으로 교체
- 이진 파일을 메모리로 덮어씌우고 실행함
- 부모가 자식이 실행되는 동안 논다면, ready에서 wait() 시스템콜을 함
![](https://i.imgur.com/QjC9NCv.png)
- 자식은 부모로부터 자원 뿐만 아니라 특권, 스케줄링 속성 물려받음
- execlp()를 이용해 자신의 주소 공간을 ls 명령어로 채움
- 자식 프로세스가 종료되면, 부모는 wait() 호출로부터 재개됨
![](https://i.imgur.com/IqHLn6Z.png)

- Windows의 경우
	- fork()랑 CreateProcess()랑 비슷함
	- fork()는 자식이 부모로부터 주소공간을 물려받지만,
	- CreateProcess()는 명시된 프로그램을 자식의 주소공간으로 덮어씌움
		- 이쪽이 파라미터가 많겠죠.. fork()는 없었는데
	![](https://i.imgur.com/Cq8GbPE.png)


- 프로세스의 종료
	- 마지막 문장을 실행하여 종료되면, exit() 시스템콜로 OS한테 나 지워달라고 요청
	- 이 때, wait() 시스템콜 후 대기중인 부모 프로세스한테 상태값 리턴
	- 프로세스의 모든 자원들이 OS에 의해 비할당/회수됨

- 부모 프로세스에 의한 종료
	- 프로세스가 시스템콜로 자식 프로세스를 종료시킴
	- 당연히 자식의 id를 알아야겠죠
	- 왜 종료시키지?
		- 자식이 할당된 자원 초과 사용
		- 자식한테 할당된 task가 필요없어짐
		- 부모가 exit인데 자식이 실행되는걸 OS가 싫어할때
			- Cascading termination! 부모가 종료되면 자식도 같이 종료되라!
			- 부모는 자식이 종료되기를 기다림. wait()으로
			- 종료되는 자식의 pid가 리턴되어서 어떤놈이 종료됐는지 식별
- 사용자가 직접 하려면 kill

- 프로세스가 종료되면, OS가 자원을 다시 가져감
- 프로세스의 exit status는 프로세스 테이블에 남아있으므로, PCB 정보는 부모가 wait() 호출할 떄까진 유지됨 ㅋㅋㅋ

- 좀비 프로세스
	- 종료되었지만 부모가 아직 wait()을 안 한거
	- 모든 프로세스는 종료하면 짧은 시간 동안은 좀비임
	- 부모가 wait()을 하고 나서야 좀비 프로세스의 pid와 PCB가 제거됨

- 고아 프로세스
	- 부모가 wait()을 호출하지 않고 종료가 되버리면 자식은 고아가 됨
	- 이럴 땐 init을 고아의 새로운 부모로 만들어서 해결
	- init이 주기적으로 wait()을 해서 orphan의 exit status를 수집하고,
		- 고아의 id와 프로세스 테이블 항목 해제
		- 리눅스는 init대신 systemd 씀 ㅋ

- 모바일은 제한된 자원의 회수를 위해 프로세스를 종료, 중요도가 낮은 것부터 강제로!
	- Empty - Background - Service - Visible - Foreground 순으로 종료
	- EBS는 5층(V Floor)에 있다로 외우자
	- 범주가 여러개 겨치면, 가장 높은 순위로 간주함 (가장 높은 순위로 매겨주려 함)

# 3.4 프로세스 간 통신

- 프로세스는 OS에서 병렬적으로 실행됨, 어떻게?
	- 독립적으로 : 다른 프로세스와 데이터 공유 안함
	- 협력적으로 : 다른 프로세스에 영향을 받음

- 왜 협력적으로 하나요?
	- 정보를 공유하고
	- 계산속도도 빨라지고
	- 모듈화가 되니까요~


- 이렇게 협력적 프로세스는 IPC 메커니즘이란걸 필요로 해요
	- 데이터를 주고받을 수 있게 하는 메커니즘이죵
	- IPC는 크게 두종류의 모델
		- 메모리 공유 모델 (공유 메모리로 정보교환)
			- 빠름(공유 메모리 영역을 만들떄만 시스템콜)
			- 일단 만들면 모든 접근이 일상적인 메모리접근 취급, 커널 노필요
		- 메세지 패싱 모델 (메시지를 교환해서 정보교환)
			- 적은 양 교환할땐 편함
			- 구현하기 쉬움
			- 느림 (시스템콜을 자주)

# 3.5 IPC in Shared-Memory Systems

- 제작자-소비자 문제
	- 한쪽은 정보를 생산, 한쪽은 소비 
	- 이럴 때 shared memory a.k.a 버퍼를 써요
	- 이러면 제작자/소비자 모두 동시에 실행 됨 by 버퍼
	- 프로듀서 : 버퍼 채워~ // 소비자: 버퍼 비워~~
	- 버퍼는 당연히 공유메모리 영역에 있음
	- 동기화 필수 : 프로듀스 안 된 걸 소비할순 없겠죠?

- Bounded buffer in IPC
- ![](https://i.imgur.com/ieSm2ci.png)

	- 두 포인터를 갖는 원형 배열로 구현
	- in == out 이면 버퍼가 비었다
	- (in+1) % 버퍼사이즈 == out 이면 버퍼가 꽉찼다

# 3.6 메세지 패싱 IPC

- 데통에서 많이 하는거라..
- 자세히 외우진 말고 큰틀에서 짚고만 가자
- 상대를 직접 명시해서 직접통신 /메일함 기반 간접통신
- 동기화/비동기화
- 메세지 저장큐의 용량이 각각
- 직접 연결 통신
	- 프로세스 이름 명시해야됨 by 어드레싱(네이밍)
	- 1) 대칭성이 있는 경우 send(P,message) P에게보내 recieve(Q,msg) Q에게서 받아
	- 2) 비대칭인 경우 : send(P,message) P에게 보내 recieve(id,msg) 누군가한테서 받아 받아
	- 단점 : 모듈화하기 힘듬, 코딩하기 빡셈, pid 바꾸면 다른것도 다 바꿔야함
- 간접 연결 통신
	- 메일함 이용
	- send, recieve(A,msg) A메일함에서 보내/가져와
	- 둘다 공유된 메일박스가 있어야겟죠
- 동기화
	- 프로세스간 통신은 send() recieve()로 발생하는데
	- 동기화(blocking) : 수신가능할때까지 송신대기 
		- 마찬가지로 송신가능해질때까지 수신대기
		- 주거나 받거나 제대로 못함
		- 이렇게 양쪽다 블록킹이면 생산자-소비자 문제 적용가능
	- 비동기화(nonlblocking) : 보낸 후 계속 할일

- 버퍼링
	- 직접/간접이든 메시지는 큐에서 보관됨
		- 보관을 안하는 경우
		- n개 메시지까지만 보관하는 경우
		- 무한개 보관하는 경우의 큐가 있겠죠
