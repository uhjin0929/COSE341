# 그래서 운영체제(OS)가 머임??

- <span style="font-weight:bold; color:rgb(192, 0, 0)">컴퓨터의 하드웨어를 관리하는 소프트웨어</span>
- <span style="color:rgb(0, 176, 80)">응용 프로그램을 위한 기반</span> 제공
- 사용자-하드웨어 사이 중재자 역할
- 기본적으로 해야 하는 일은, 
	- <span style="font-weight:bold; color:rgb(192, 0, 0)">(CPU, 메모리, I/O 디바이스, 스토리지) 를 프로그램에 할당</span>하는 것!


# 1.1 그래서 OS는 무슨 일을 하는가
![|400](https://i.imgur.com/42ySzfr.png)

- 우선, 컴퓨터 시스템 Structure는 크게 4가지의 요소로 구성된다.
	- 사용자😎
	- 응용프로그램
	- <span style="font-weight:bold; color:rgb(192, 0, 0)">OS : 하드웨어(특히 CPU)를 제어. 사용시간을 공평하게 분배하도록 메모리를 관리.</span>
		- 다른 프로그램들이 효율적으로 돌아가게 하는 환경을 조성!!
	- Hardware 

- **OS가 하는일 : 사용자 관점**
	- 인터페이스(PC,놋북,모바일) 에 따라 다양함
	- PC, 놋북 : 한 사용자가 독점 사용하니 자원 공유는 신경 안씀
	- 모바일기기(스마트폰, 태블릿) : 네트워크로 연결되어 있음
	- 내부 컴퓨터 : UI가 없고, 유저의 간섭을 상정하지 않은 설계임
- **OS가 하는일 : 시스템 관점**
	- 하드웨어와 가장 밀접한 프로그램
	- **Resource Allocator(자원할당자) : 공평한 자원 할당**
		- 특정한 프로그램과 유저들에 대해 자원을 어떻게 할당할지 걱정
		- 공평/효율적으로 컴퓨터 시스템이 동작하게 함
	- Control Program(장치/프로그램 제어, 프로그램 실행 제어)
		- 다양한 I/O device와 user program을 제어
		- 프로그램 실행 제어 $\Rightarrow$ (Error / 컴퓨터의 부적절한 사용)을 막음

- 용어 'OS'는 많은 역할과 기능을 커버함 $\Rightarrow$ 정확한 정의라는 건 없습니다
- PC가 대중화되면서, OS 또한 점점 섬세해지고 있음
- 정의 1) Control / Allocate 에 필요한 기능들을 **하나의 소프트웨어**로 모아놓은 것
- 정의 2) 컴퓨터에서 **항상 실행**되고 있어야 하는 핵심 프로그램 $\Rightarrow$ **커널!**
	- System program : OS는 관련 있지만 커널의 필수파트는 아님. 필요 시 실행
	- Application program : 시스템의 operation과 무관한 모든 프로그램들

# 1.2 컴퓨터 시스템의 동작

![](https://i.imgur.com/bmPkKvb.png)

- 하나 이상의 **CPU와 디바이스 컨트롤러**가 **common bus**를 통해 연결되고, **shared memory**에 접근한다.
	- CPU와 디바이스 컨트롤러는 **메모리 사이클**을 놓고 경쟁 $\Rightarrow$ **병렬** 실행!
	- 각 디바이스 컨트롤러는 특정 디바이스를 관리
		- 컨트롤러는 로컬 버퍼 스토리지와 특수 목적 레지스터를 유지
	- OS는 각 디바이스 컨트롤러에 대해 **드라이버**를 가지고 있음

![](https://i.imgur.com/1nP7x35.png)

- CPU는 (메인 메모리 $\iff$ 디바이스 컨트롤러의 로컬 버퍼) 사이에서 데이터를 운반합니다
- I/O는 (디바이스 $\Rightarrow$ 디바이스 컨트롤러의 로컬 버퍼 ) 단방향으로 합니다.
- 디바이스 컨트롤러는 **Interrupt** 라는 걸 일으켜서, CPU에게 너가 할 일이 끝났다고 알려줍니다.

### Interrupts

- CPU에게 메세지를 전달하는 방법입니다.
- CPU가 장치의 작업이 끝났는지 지속적으로 확인할 필요가 없어서 효율적이죠
- 예) 임의의 프로그램에서 키보드로부터 데이터를 읽어오는 과정
	1. OS의 장치 드라이버가 장치 컨트롤러 내의 적절한 레지스터에 명령을 로드
	2. 장치 컨트롤러가 로드된 명령을 확인하고, 어떤 작업을 수행할지 결정
		예) 명령 : 키보드에서 문자를 읽어와 $\Rightarrow$ 키보드로부터 데이터 읽자~
	3. 장치 컨트롤러가 데이터를 읽어온 후, 그 데이터를 로컬 버퍼에 일시적으로 저장
	4. 장치 컨트롤러가 작업이 완료되었음을 알리기 위해 CPU에 interrupt를 발생
		- 다 했다는 신호를 CPU에게 보냄
	5. CPU가 장치 컨트롤러로부터 받은 데이터를 메모리로 이동 후, OS의 다른 부분이 데이터를 사용할 수 있도록 제어를 넘김. 이 때 OS는 데이터를 처리하거나, 데이터의 포인터를 넘겨줌.
	6. OS가 상태 정보를 반환함. (작업 완료/사용중)


- IO장치는 언제든지 CPU로 보내 인터럽트를 발생시킬 수 있음 (by 시스템 버스)
	- 입출력 작업을 수행하는 도중, CPU에 작업 완료/상태 변화를 알리기 위해!

- CPU가 인터럽트를 받으면, 현재 하던 작업을 즉시 멈추고, 미리 인터럽트 서비스 루틴의 시작 주소가 포함된 위치로 실행 제어를 넘김
- 인터럽트 서비스 루틴이 실행되면서, 발생된 인터럽트에 맞는 작업을 수행
	- I/O장치로부터 데이터를 읽거나, 작업이 완료되었음을 확인하는 등..
- CPU는 인터럽트 처리가 끝나면, 이전에 하던 일을 이어서 수행함.

![](https://i.imgur.com/9Yy5zJG.png)

- I/O request : I/O가 데이터를 전송하거나 처리 요청을 보낸후 IDLE 상태가 됨
- Transfer done : I/O 장치에서 데이터를 전송 완료하면, CPU에 인터럽트가 발생함
- Interrupt signaled : I/O가 인터럽트 신호를 보내면, CPU가 감지하고 IDLE로
- Interrupt handled : CPU가 인터럽트 서비스 루틴을 실행해서 해당 인터럽트를 처리한 후, 원상태로 복귀

- 인터럽트는 반드시 제어를 인터럽트 서비스 루틴으로 이동한 후 처리해야한다.
- 인터럽트는 빨리 처리되어야 한다, 존나 자주 발생하기 때문
	- 속도를 맞추려고 인터럽트 서비스 루틴들의 포인터 테이블을 씀
	- 당연히 이 테이블은 low memory에 저장되겠죠?
	- 이 주소들의 어레이는 고유한 숫자를 가지는 인덱싱이 됨.
		- 각 I/O 장치에는 미리 인덱스번호가 할당되고,
		- 장치별로 처리하는 인터럽트 서비스 루틴이 있고,
		- 서비스 루틴의 주소가 테이블에 저장되어있는 거임
		- 인터럽트가 요청되면, 해당 인덱스로 테이블에서 주소를 검색함.


- 인터럽트된 기존의 모든 상태정보는 저장되어야 함
	- 레지스터, 지금까지 처리명령, 다음 처리해야 할 명령..
- 인터럽트를 처리하고 난 후 이 정보들을 복구하는거임
- 인터럽트가 처리되고 나면, 저장된 리턴어드레스가 Program Counter로 로드됨
- 복구되면, 마치 발생하지 않았던 것처럼 이전 작업을 계속 수행

![](https://i.imgur.com/rBV0IKD.png)

1. 장치 드라이버 입출력 개시
	 OS의 장치드라이버 "CPU야~ I/O작업 수행해"
2. I/O컨트롤러가 I/O장치와 통신해서 입출력 작업 실행
3. I/O가 인터럽트 신호를 발생
4. CPU는 작업을 진행하는 동안 명령어 사이에 인터럽트가 있는지 확인
5. 인터럽트가 도착하면, CPU는 현재 작업을 멈추고 인터럽트 서비스 루틴으로 제어를 넘김
6. 인터럽트 처리 루틴이 실행됨. (인터럽트에 맞는 작업이 수행)
7. 처리 루틴이 완료되면 CPU는 원래 작업을 이어서 수행


- CPU 하드웨어는 interrupt-request line이라는 wire를 가지고 있다.
- 이 wire는 CPU가 매번 명령을 실행한 후 인터럽트가 발생했는지 감지하는 역할을 함
- I/O 컨트롤러가 인터럽트 신호를 보낼 때, CPU는 wire에 신호가 있는지 확인
- 신호가 감지된다면, 인터럽트 번호를 읽고 interrupt handler 루틴으로 점프해서 해당 루틴을 실행.

- 요약하자면, (1) 디바이스 컨트롤러가 인터럽트를 발생해서 wire에 신호를 보낸다
- (2) 컴퓨터가 신호를 잡아서, 인터럽트 핸들러 루틴으로 점프해서 해당 루틴을 실행한다
- (3) 인터럽트 핸들러 루틴이 인터럽트를 처리하고, 작업의 완료되면 인터럽트를 지운다.

- 인터럽트의 기본 메커니즘은, CPU가<span style="color:rgb(192, 0, 0)"> aynchronous</span> **이벤트에** 대응할 수 있게 함
	- 디바이스 컨트롤러가 준비가 되면, CPU가 <span style="font-weight:bold; color:rgb(192, 0, 0)">waiting 없이</span> 응답해서 처리한다는 거임! 

 - 현대 OS에서는 인터럽트를 다룰 때 좀 더 세련된 방식을 씀
	 - CPU나 인터럽트 컨트롤러 하드웨어로 하는데..
	 - 처리를 연기한다던지.. 적절한 인터럽트 핸들러 루틴을 쫓아가는 효과적인 방법이라던지..
	 - 인터럽트 별로 우선순위를 둔다던지..

- 인터럽트 리퀘스트 라인(wire)의 두  종류
	- (1) nonmaskable interrupt
		- 복구 불가능한 메모리 오류와 같은 이벤트를 위해 예약된 인터럽트
		- 빠른 처리 필요
	- (2) maskable interrupt
		- 인터럽트 끄기 (무효화, 0->1 상쇄)
		- 중요한 신호처리가 들어오면 지금 하고 있는 덜 중요한 신호를 무효화
		- 서비스를 요청하기 위해 디바이스 컨트롤러가 사용

- 질문) Interrupt vector보다 장치 개수가 많으면 어떡해요?
- 해결) Interrupt chaining! : interrupt vector의 각 원소들이 interrupt handler들의 리스트의 시작주소를 포인트
	- 인터럽트가 발생하면 서비스를 요청한 대상을 찾을 때까지 하나씩 리스트 호출
	- 큰 interrupt 테이블을 유지할지? interrupt handler 하나로 처리할지는 잘 타협해서 정하기


### Storage Structure

- hierarchy가 존재함
- CPU에 가까운 친구일수록 속도 빠름, 비싸고, 용량은 낮음
![](https://i.imgur.com/dBGR5Mg.png)

### I/O Structure
![](https://i.imgur.com/PdJUPYJ.png)

- 인터럽트 기반 입출력은 대용량 전송 시 높은 오버헤드가 걸림
- DMA(Direct Memory Access)
	- CPU 개입 없이, 설정된 전체 블록을 직접 전송
	- block 당 하나의 인터럽트를 발생시켜 IO 완료를 알림
	- 디바이스 컨트롤러가 일처리 하는 동안 CPU가 다른 일 처리 가능

# 1.3 Computer-System Architecture

- 저장장치에 저장된 상태면 **프로그램**
- 프로그램을 실행하려고 메모리에 올리면 **프로세스**
- 프로세스를 갖고와서 처리하는 역할이 **프로세서**
### Single-Processor System 

- 하나의 CPU(core가 1개!!)를 갖는 시스템
- core : 명령어를 실행하고, 데이터를 local하게 저장하는 요소
- **core가 1개인 범용 cpu가 1개 : Single processor system**

### Multiprocessors Systems

- 여러개의 싱글코어 cpu를 갖는 시스템
- 프로세서가 여러개고, **각각**은 싱글코어 CPU **하나씩**
- 프로세서들이 컴퓨터 버스나 클락,메모리,주변기기를 공유함
- 머가 좋은데요? 처리량이 증가하니 시간 적게 걸리고 (N배 scalable하진않음 ㅋㅋ)

- Multiprocessors System은 두가지 종류가 있어용
	- AMP : 프로세서가 실행하는 task가 구분됨
		- 코어 간 기능 차이**있음**
	- SMP : 프로세서가 실행하는 task의 구분이 없음
		- 가장 흔한 시스템이고, core 간 기능 차이 없음!!

![|500](https://i.imgur.com/oSvzqzW.png)

- SMP
	- 코어들의 기능이 대칭이란 뜻 (차이가 없음)
	- 각각의 peer CPU 프로세서들이 실행하는 task의 구분이 없다
	- 각 CPU가 자신의 register와 cahce로 개별 작업을 처리함
	- CPU들은 모두 독립적이므로, 하나는 IDLE인데 하나는 OVERLODED인 비효율적인 상황 가능
	- 모든 프로세서들이 시스템 버스를 통해 물리적 메모리를 공유함
	- 여러 프로세스들이 큰 성능 저하 없이 동시실행 가능!

### Multicore systems
![|400](https://i.imgur.com/5kCpmpK.png)

- 멀티프로세서에서 업그레이드가 좀 된 구조인데
- 여러 칩에 단일 코어 $\Rightarrow$ 하나의 칩에 여러 코어 (더 효율적)
	- on-chip 통신이 between-chip 통신보다 빠를테니까..
	- 전력도 덜 먹어요 (이건 모바일에서 중요하겠죠?)

- 각각의 코어들이 자기 자신의 register set, local cache를 가짐
- L2 cache가 칩에 로컬로 존재하지만, 두개의 프로세싱 코어가 공유함


### Multiprocessor System은 CPU 추가도 가능함

- 성능은 향상되는데, scalable하진 않아
- 너무 많아지면 시스템 버스에 대한 경쟁이 일어나서 성능 저하됨


- 해결책 : NUMA
	- 각 CPU에 작고 빠른 local bus로 접근 가능한 자신만의 메모리 제공
	- 모든 CPU가 공유 시스템에 연결되고, 한 물리주소공간을 공유함
	![|500](https://i.imgur.com/QYHuavj.png)
	- 이점 : CPU가 local 메모리에 접근할 때 빠르고, 공유시스템에 대한 경쟁 X (scalable!)
	- 단점 : CPU가 원격 메모리에 접근할때 레이턴시(지연시간) 증가 가능 -> 성능저하...
	- 어케 최적화? CPU 스케쥴링과 메모리 관리! 


### Blade servers

- 여러 프로세서 보드, I/O보드, 네트워킹 보드가 하나의 섀시에 배치된 시스템
- 전통적 멀티프로세서 시스템과의 차이
	- 각 보드에서 독립적으로 부팅하고 자신의 OS를 실행함
	- 이 서버는 multiple independent multiprocessor system으로 구성되어 있음

### Cluster Systems

- 여러개의 CPU가 있는 멀티프로세서 시스템 유형
- 전통적 멀티프로세서 시스템과의 차이
	- 두개 이상의 노드로 구성
	- 각  노드는 멀티코어 시스템이고, 느슨하게 결합되어 있음
- 각 시스템은 저장소를 공유하고, LAN이나 빠른 인터커넥트를 통해 밀접연결

- 장점 1) High-Availability service 
	- 어떤 시스템이 문제가 생겨도 다른 애들이 받아서 처리함
- 장점 2) 높은 퍼포먼스의 컴퓨팅 환경
	- 클러스터에 있는 모든 컴퓨터에 의해 병렬적으로 어플리케이션이 실행됨

- 안정성이 좋아지겠죠?
	- high availability니까
	- 남은 머신에 비례해서 서비스를 계속 제공할테니, 급격한 성능 저하 x
	- failure에도 불구하고 계속 동작 가능

- 클러스터 시스템은 asym/symmetric하게 다 구현될 수 있음

- Assymetric의 경우 : 노드들의 기능이 차이가 있음
	- 하나는 긴급대기 모드, 다른 하나는 돌리고..
- Symmetric의 경우 : 노드들의 기능이 차이가 없음
	- 서로서로 모니터링 하면서 어플도 돌림. 노는 노드 없이 모두 사용


# 1.4 Operating System Operations

### Initial Program

- 컴퓨터를 실행하려면 초기프로그램을 실행해야됨
- 얘는 펌웨어로 하드웨어에 저장되고, 부팅 시 실행됨

1) 시스템 초기화
2) OS 커널을 찾아서 메모리에 로드함
3) 시스템, 사용자에게 서비스를 제공함

이것이 끝나면, 바탕화면이 뿅 나오는거죠


### Events

- 이벤트는 인터럽트를 발생시켜 신호를 보냄
- 하드웨어 인터럽트는 디바이스 하나로부터
- 소프트웨어가 만드는 인터렙트는? Trap / Execption이라고 부름
	- 소프트웨어 에러(0으로 나누기, 이상한 메모리 접근)
	- system call을 통해 OS 서비스가 실행되어야 처리하는 사용자 프로그램의 특별 요청인 거죠!
	- 트랩은 exeception, systemcall 두가지 경우로 발생

### Multiprogramming

- 메모리에 동시에 여러 프로그램을 올려서 동시에 실행하는 거
- CPU 사용을 늘리고 유저들도 만족 시키고..

- 프로세스 : 실행 중인 프로그램
- OS는 메모리에 여러 프로세스를 동시에 담아둡니다
- CPU가 안 놀고 계쏙 일처리 할 수 있게, 순차적으로 갑니다..


### Multitasking

- 멀티프로그래밍은 CPU 입장에서의 일처리로 보면? 멀티태스킹이라고 하죠
- 멀티태스킹 시스템에서
	- CPU가 여러 프로세스를 스위칭으로 실행하곤 하죠
	- 스위치가 자주 일어나서, 사용자에게 빠른 응답시간 제공
	- CPU가 쉬지 않고, 대화식 처리, 다른 사용자 프로세스로 스위치함

- 예 ) 대화식 I/O 처리 (cpu 입장에선 엄청 긴시간임)
- CPU가 쉬지 않고 다른 사용자 프로세스로 switch함 

- 멀티태스킹을 위해 OS에 있어야하는 기능
	- 여러 프로세스를 동시에 메모리에 넣어놔야 하니까, 메모리 관리가 필요
	- 여러 프로세스를 돌릴준비를 동시에 하려면, 시스템이 다음에 돌릴 놈을 정해야함 (CPU 스케쥴링!)
	- 여러 프로세스를 동시에 실행하려면, 서로 영향을 미치는 기능은 제한되어야 함

## Dual-Mode and Multimode Operation

- OS와 사용자는 자원을 공유함
- OS는 프로그램이 잘못 실행되지 않도록 보호해야 함
- OS 코드의 실행과 사용자정의 코드의 실행을 구분해야 함

- 그래서 operation에 두개의 구분된 모드를 사용
	- (0) : 커널 모드 : 다 할 수 있음
		- 특권 명령어 : 커널 모드에서만 실행됨
			- I/O 컨트롤, 타이머 관리, 인터럽트 관리
			- 이건 유저모드에서 실행되면 무시됨
	- (1) : 유저 모드. 커널명령어 쓰는 거 금지. 사용자 프로그램 실행

- 시스템에서 다양한 실행 모드를 구별할 수 있도록 하드웨어적으로 지원함
- 부팅되면 커널 모드로 시작, OS가 load되면 사용자 어플리케이션이 유저모드에서 시작

- 유저모드에서 사용자 어플리케이션
	- 트랩/인터럽트가 발생하면, 하드웨어가 유저모드(1)에서 커널모드(0)로 바꿈
	- 잘못된 사용자로부터 OS를 보호하는 방법을 제공

- System call
	- processor 기능에 따라 다양한 방법으로 호출됨
	- 보통 인터럽트 벡터의 특정 위치로 트랩 형태로 발생
	- 시스템에서 syscall 명령어가 제공됨
	- 하드웨어 보호가 설정되면 모드위반 오류를 감지함
	- 이런 오류들은 OS에 의해 처리됨
		- 1) 사용자 프로그램이 모드 위반으로 fail되면, 하드웨어가 OS에 트랩을 발생
		- 2) 트랩은 인터럽트 벡터를 통해 OS에 전달
		- 3) 오류를 발생한 프로그램은 OS에 의해 비정상적으로 종료
		- 4) 적절한 오류 메시지 제공, 메모리 덤프

- 모드가 여러개로 확장되기도 하고 그럼 ㅋ

### Timer

- 사용자 프로그램이 무한 루프에 빠지거나, 실행 후 OS로 제어가 안 넘어오고 그러면 안됨

- 타이머는 특정 시간 후 인터럽트가 발생하도록 설정 (고정/가변)
- 유저 프로그램 실행 전에, OS는 타이머가 인터럽트 할 수 있도록 설정함
- 타이머가 인터럽트 되면, 제어가 자동적으로 OS로 넘어옴

# 1.5 Proess Management

### Process Management
- 프로세스 : 실행중인 프로그램 .
	- 다음 수행할 명령어에 대한 프로그램 카운터를 가짐
	- 프로세스는 순차적으로 수행됨
	- 한번에 하나의 명령만 수행됨


- 프로세스가 병행 실행되도록, 서브프로세스를 생성하는 systemcall을 제공할 수 있음
- 프로세스는 자원이 필요함
	- 돌아갈때는 자원이 할당되고
	- 종료되면 프로세스에 사용된 자원 반납!

- OS는 프로세스를 관리하는 책임이 있음

- 프로그램이 실행되려면 매핑



### Memory Management

- instruction은 메모리 안에 있음
- CPU가 메모리에서 inst를 읽어오고.. 데이터도 읽어오고..

- 프로그램이 실행되려면 절대주소로 맵핑된 후 메모리로 로드되어야 함
- 프로그램이 실행되면서 메모리의 명령어/데이터에 접근
- 프로세스가 종료되면 메모리 해제
- CPU의 이용률과 사용자 응답속도를 모두 높이려면, 메모리 관리 필요!
- OS는 메모리 관리 책임이 있음
	- 어느 부분이 사용되고, 어느 프로세스가 사용하는지 추적
	- 필요한 메모리 공간 할당 및 회수
	- 어느 프로세스/데이터가 메모리에 들어가고 나갈건지 결정

### Cache Management

- 캐싱은 컴퓨터 시스템의 중요한 원리
	- 정보는 보통 메인 메모리에 저장되지만..
	- 데이터가 사용이 되면서, 더 빠른 캐시에 일시적 저장
	- 특정 데이터 필요하면 캐시를 먼저 확인
	- 데이터를 사용후, 재사용을 가정하고 캐시에 복사본 저장

- 캐시는 크기가 제약되므로, 관리해줘야함 ㅎ

- 동일 데이터가 저장체계의 다른 계층에서 중복저장되어있을 수 있음
- 레지스터에서 + 연산되면 A의 값이 서로 다르니까
- 레지스터 값을 디스크에 기록할 때가 되어서야 바뀐 값이 반영되는 거임
- 그러니까, 한 데이터를 여러 프로세스가 사용하는 경우,
	- 가장 최근에 업데이트된 데이터값을 얻는 게 보장 되어야 함
	- 이걸 데이터일관성 이라고 함!
	- 하나의 데이터가 연결된 여러 노드에 복사본이 저장되어있으면,
	- 한곳에서 수정되면 다른 곳에서도 업데이트 되어야 한다!!!

- 멀티프로세서 환경에서는, 동일한 변수가 여러 캐시 안에 저장될 수 있음
	- 업데이트 결과가 즉시 다른 모든 캐시에 반영되어야 함 (캐시 일관성!)