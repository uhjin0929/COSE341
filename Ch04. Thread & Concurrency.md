- 프로세스는 예전에나 쓰던거지! 현대 컴퓨팅은 쓰레드라는 단위를 쓴다!!
- 현대 OS에서는 한 프로세스가 다중 쓰레드를 포함함
- 다중 CPU를 제공하는 멀티코어 시스템에서 쓰레드를 통한 병렬처리가 중요!

- 쓰레드 : CPU를 사용하는 기본 단위
	- pid처럼 tid를 갖고있고, 프로그램 카운터, 레지스터셋, 스택 다 있죠
	- 동일 프로세스에 속하는 쓰레드는 코드,데이터,자원,파일신호 공유함
- 이렇게 프로세스가 여러 쓰레드를 다룰 수 있으면
- **동시에 하나 이상의 태스크 실행 가능!** (중요)

![](https://i.imgur.com/x1GJncN.png)

- 요즘은 소프트 어플리케이션이 거의다 멀티 쓰레드임
	- application : 여러개의 쓰레드를 제어하는 분리 가능한 프로세스
	- 병렬이라 처리능력이 향상 되겠죠
	- 현대 OS는 쓰레드를 씀
	- 한 프로세스가 멀티플 쓰레드를 쓰면 더 효율적
		- 다른 프로세스를 만들 필요 없이, 새로운 쓰레드를 만드는 거임
		- 기존에는 새로운 프로세스를 만들었지만.. 이걸 새로운 쓰레드 만드는걸로

- OS커널도 멀티쓰레드임
- pid=2 kthreadd가 모든 커널 쓰레드의 부모임
- 멀티쓰레드 프로그래밍의 이점
	- 시간과 자원을 덜 먹어서 사용자 요청에 빨리빨리 처리 가능
		- UI를 디자인하기 편해짐
	- 자원 공유
		- 프로세스는 shared memory/메세지 패싱으로만 자원공유 했지만
		- 쓰레드끼리 속한 프로세스의 메모리와 자원들을 공유한다
		- 동일한 주소공간에 여러 쓰레드니까
	- 경제성
		- 프로세스 생성할때 메모리/자원을 할당하니 비용이 많이 들지만
		- 쓰레드는 덜 먹음. context switcingㄷ 빠르니까
	- 확장성
		- 씽글쓰레드는 코어가 많아도 한 프로세서에만 실행되지만
		- 쓰레드는 다른 코어에서 병렬 수행 가능
		- **코어마다 쓰레드를 붙여서 병렬적으로 수행, 코어가 많아지면 성능 굿**
	- 컴퓨팅 성능 향상
		- 다중 컴퓨팅코어를 효율적으로 사용, 병행성 향상
		- 싱글코어에선 멀티쓰레드가 엄밀히 말하면 동시실행은 아니지
			- 번갈아 실행되는거임 이름이 병행이어도
			- ![](https://i.imgur.com/NaBlybc.png)

		- 멀티코어에서는 개별 쓰레드가 각 코어에 할당이라, 병렬실행임
- concurrent (병행) : 둘 이상의 task를 지원하지만 병렬은 아니다. 한 시점엔 하나만
- parallel (병렬) : 둘 이상의 task가 동시에 실행됨, 병렬 맞음

- 멀티코어 시스템에서 프로그래밍 시 고려 사항
	- 1) task를 identifying해서 잘 나누기 (독립된 병행태스크로 나눠지는 곳 찾기)
	- 2) 균형 : task들이 균형하게 처리
	- 3) data splitting : 데이터도 잘 나눠야
	- 4) data dependency : 관계있는 데이터는 묶어서 하나로 실행
	- 5) test/debug : 다양한 실행 경로
- 이걸 다 고려해서 프로그래밍 해야, parallel하게 실행되어 성능이 좋아짐


- Amdahl's law 
- 순차 실행되는 부분이 S(0~1)라면, N개의 코어일 때 성능향상은!
$$speedup \le \frac{1}{S+\frac{(1-S)}{N}}$$
- 예) serial 25퍼센트면, speed업은 맥시멈 1.6
- 순차실행되는 부분이 코어 추가시 속도에 영향을 주는거임
- N이 무한대로 커져도 1/S로 수렴하니, 결국 serial이 좌우!
- 실질적으론 serial/병렬 다 있기떄문에 이상적으로 커지지 않고 요렇게 커지는 거

- parallelism 의 두 종류
	![](https://i.imgur.com/pXOvegY.png)

	- data parallelism : 데이터를 여러 코어에 분배 (동일 연산)
	
	- task parallelism : task를 여러 코어에 분배 (쓰레드마다 고유 연산산)
	- 두 병렬화는 상호 배타적이 아님, 혼합임


# Ch4.3 멀티쓰레딩 모델

- 유저레벨의 유저 쓰레드와, 커널레벨의 커널쓰레드 (실제 CPU 코어위에 올라오는애)
- 유저쓰레드 : 커널 상위에서 실행, 커널 지원 없이 관리, 시스템콜 대신 유저레벨 쓰레드 라이브러리
- 커널쓰레드 : OS에 의해 직접 관리하니 시스템콜 씀
- 유저쓰레드와 커널쓰레드의 관계는 크게 3가지로 나눔
	- 다대일 (유저여럿 커널하나)
		![|300](https://i.imgur.com/4P5xcZ4.png)

		- 한번에 한 스레드만 커널에 접근함, 병렬 x
		- 쓰레드가 블록 시스템콜을 하면 전체 프로세스가 블록됨
		- 쓰레드 관리는 라이브러리에서 해서 효율적
		- 다중 코어를 활용못함!
	- 일대일 모델
		- 여러 쓰레드가 병렬로 실행 가능
		- 다대일보다 병행성 좋음
			- 스레드가 블록해도 다른 스레드가 실행 되니가
		- 유저 쓰레드 생성시 커널 쓰레드도 생성되므로 1:1을 맞춰야해서 시스템이 부담
		- 코어보다 스레드 많아지면 스위칭도 해야하고, 자원도 많이 들어서 성능 저하
	- 다대다 모델
		- 다대다여도 유저 >= 커널 입니다!
		- 위의 N>=n 개가 밑에 n개를 번갈아서 쓰는거죠
		- 병행성의 effect (프로그래머 관점)
			- 다대일은 원하는 만큼 쓰레드 생성 가능, 병렬 x 한번에 하나씪 스케줄됨
			- 일대일은 병행실행 되지만 너무 많이 안되게 신경
			- 다대다는 위의 단점이 없음
			- 개발자는 필요한만큼 유저쓰레드 만들고~ 대응되는 커널이 병렬로!
			- 한 스레드가 블록킹 시스템콜을 하면, 커널이 다른 스레드를 실행
		- 더 유연하지만, 복잡해서 실용성 떨어짐
	- 요즘 OS들은 거의다 일대일!
	- 왜냐면 코어가 늘어나서 커널 쓰레드 수를 제한 걸 필요가없음


# 4.4 Thread library (간단하게만)

- 프로그래머에게 쓰레드를 생성/관리하기 위한 aPI를 제공

- 구현 방법은 크게 두개
	- 커널 지원 없이, 유저스페이스에서 제공(시스템콜이 아니라, 로컬함수)
	- OS가 직접 커널레벨 라이브러리 제공(시스템콜)
- Asynchronus (비동기)
	- 부모가 자식 생성 후 실행 재개
	- 둘은 동시/독립적 실행 (당연히 데이터공유 없음)
	- 멀티쓰레드 서버에서 자주 씀
	- 반응형 UI 만들떄도 씀
- synchronus (동기 스레딩)
	- 부모가 모든 자식 스레드가 종료될 떄까지 기다림
	- 자식은 병행적으로 실행, 종료 후 parent 실행
	- 자식이 끝나면 parent와 조인함
	- 모든 자식이 join되어야 parent가 실행 재개
	![](https://i.imgur.com/IJqhW88.png)
	- 이걸 추가시켜야 조인연산!
	- 데이터 공유 쩔음
	- 윈도우도 여러스레드 하려면 Waitformultipleobject 함수 써야함
	![](https://i.imgur.com/PlN0UaY.png)

# 4.5 Implicit Threading

- 다중 코어 성장, 다중 스레드 응용이 등장하면서
- 쓰레드 생성/관리를 프로그래머가 직접 처리하기 어려워짐
- 컴파일/라이브러리에게 떠넘기는 방법!입니다

- Explicit은요? 하드웨어 개발하는 사람들이 하는거..
- 개발자들이 parallel task를 식별만 함, library가 결정!


# 4.6 Threading Issues 

- 스레딩 해볼떄 고려해야할 것
- fork()와 exec() 시스템콜의 의미 : 어떤 스레드를 복제? 어떤애들 실행?
	- 해당 스레드만? 모든 스레드를?
- signal을 어디로 전달? 일으킨놈만? 모두? 특정?
	- 내부든 외부든 시그널 생성 -> 프로세스 전달 -> 시그널 처리 과정은 같음
	- 내부(동기적) : 시그널을 야기한 스레드에게 전달
	- 외부(비동기적) : 불분명
- 공유자원에 있는 값을 바꾸다가 스레드가 취소되면 어케 처리?
	- 비동기적 취소 : 다른프로세스에 의해 즉시 종료됨
	- 연기된 취소 : 스스로 종료되어야 하는지 확인하고 순차적으로 종료가능
	- 취소는 취소여부를 결정하는 flag 검사 이후 일어남
	- 안전하게 취소될 수 있는 시점.. 지금 취소하면 데이터 삑나!! 를 판단
- 자신만의 저장소가 필요한 스레드는?
	- 이런걸 TLS라고 함.
	- TLS랑 지역변수를 헷갈릴 수 있는데
	- 지역변수는 단일 함수 호출에만 보이지만
	- TLS는 전체함수에 걸쳐보임 (오히려 스레드별 고유한 전역변수라고 보면 되죠)

- Scheduler Activations (중요!!!!!)
	- 커널과 쓰레드 라이브러리 간 통신을 어떻게 할거냐?
	- 다대다와 그 변종일때 필요하겠죠
	- M개의 유저쓰레드를 N개의 커널쓰레드의 매핑하기 위한 동작 (N<M)
	- 이걸 위해 커널과 유저쓰레드 사이에 LWP라는 자료구조를 둠
	- ![|300](https://i.imgur.com/xhfDF0D.png)
	- 유저 레벨에 위치하지만, 커널에 의해 제어됨!
	- 커널 쓰레드의 수를 동적으로 조절함
	- 유저쓰레드 라이브러리입장에서는 LWP가 유저쓰레드를 가상 처리기처럼 보임
	- 각 **LWP는 하나의 커널 쓰레드**에 연관 (커널이 블록되면 LWP도 블록->유저도 블록)
	![](https://i.imgur.com/092ht5E.png)
	- 스레드가 하나면 1개의 LWP로 충분
	- 5개의 다른 파일을 읽는 어플이면 5개의 LWP
	- LWP가 4개라면 5번째는 기다려야지

![](https://i.imgur.com/jfKdfZ6.png)
T1 : 사용자프로그램에서 두개의 스레드 (1)(2) 가 실행 중
각 스레드는 각기 다른 CPU코어에서 실행
스레드 3,4가 레디큐에 대기중

T2 : 스레드가 (A) I/O 작업을 요청하면서 블록. CPU 코어가 다른작업을 수행하게 됨 새로운 스레드 3이 실행되기 시작

T3 : A가 I/O를 완료하고 레디큐로 이동 후 CPU 반환

T4 : I/O 요청 시 스레드가 블록되었다가, 다시 대기 상태로 들어옴


- 유저-커널쓰레드간 통신은 스케쥴러 activation이라고 함
	- upcall : 커널이 응용에게 이벤트를 알림 (LWP 제공)
		- 응용은 유저쓰레드를 가용한 LWP로 ㅅ케쥴
		- 커널은 어플에게 특정 이벤트에 대해 알림
		- 한 커널이 블록되면 새 LWP를 할당해서 다른 커널이 실행가능하도록
	- 스레드 블록 시 upcall 일으키는 이벤트 발생
	- kernel이 응용에데 upcall 해서 알리고, 새로운 LWP를 할당
	- 어플은 새로운 LWP에서 upcall handler를 실행하고,
	- 블록된 스레드의 상태 저장 후 사용하던 LWP 반환
		- 새로운 LWP에 다른 스레드 스케쥴
	- 스레드 해제 시 업콜 발생
		- 블록된 스레드가 기다리던 이벤트가 일어나면 커널은 새로운 업콜로 스레드가 계쏙 실행될 수 있음을 알림