# 2.1 Operating-System Services

![](https://i.imgur.com/YyhoidR.png)
- OS가 제공하는 기능은 크게 두 종류가 있는데요
- 1) 유저에게 도움이 되는 것들 (회색)
	- UI
	- 프로그램실행(메모리에 올리고 실행한다)
	- IO (인터럽트 관련, 사용자 직접 제어 x) 
	- 파일조작(삭제, 권한관리) 
	- 통신
	- 에러탐지
- 2) 시스템이 효율적 동작하도록 하는 애들
	- 자원할당(대표적으로 CPU 스케쥴링)
	- 로깅 : 어떤 프로그램이 어떤 자원을 얼마나 쓰는지
	- 보안 : 시스템 자원 접근 통제, 외부 접근시 인증


# 2.2 User and Operating-System Interface

- OS의 사용자 인터페이스(UI)는 이정도..?
	- 커맨드 인터프리터
		- 사실 대부분 OS에 있음 리눅스 bash shell이 대표적
		- 프로세스 초기화 시, 사용자 로그온 시 실행되는 프로그램
		- 사용자 명령을 처리함 (대부분이 파일 조작용 )
		- 커맨드 인터프리터 자체가 실행할 수 있는 코드가 내장된 경우
			- 명령어의 수가 인터프리터 크기 결정
		- 명령을 실행하는 파일이 별도로 존재하는 경우
			- 단순히 rm을 실행
			- 프로그래머가 새 명령어 추가하기 쉽겟죵
	- GUI (우리가 아는 그거)
		- 마우스, 바탕화면,...
	- 터치스크린
		- 스마트폰에서 마니쓰죠
- 당연히 인터페이스는 개취겠죠
# 2.3 System Calls

- OS 서비스에 대한 인터페이스 제공 : C, C++ 함수로 작성됨
- 단순한 프로그램도 OS의 기능을 많이 사용함 -> 수많은 시스템콜
- API : 개발자가 사용할 수 있는 함수들의 집합
	- API를 구성하는 함수들이 프로그래머를 대신해 실제 시스템콜을 함
	- 동일 API라면 어떤 시스템에서도 컴파일/런됨
	- 실제 시스템콜보다 다루기 쉬움
- RTE : 시스템콜을 처리하는 또다른 중요한 요소
	- 특정 프로그래밍 언어로 쓰여진 application을 수행하기 위한 소프트웨어 집합
	- API 함수 호출이 일어나면 이를 가로채서 필요한 OS systemcall을 호출함
	- System call에 대한 번호가 있고, 이에 따라 인덱스된 테이블 유지
- Caller는 세부내용을 알 필요없이 API를 준수하고 OS동작을 이해하면 됨
- 디테일은 API에 의해 프로그래머에게 숨겨지고, RTE에 의해 관리됨
- 파라미터를 OS에 넘기는 법 : 레지스터, 메모리블록, 조합
- 아래와 같은 6개의 카테고리로 나눌수있음
	- Process control
		- 정상적 end(), 비정상적 abort() 이후로 종료되어야 함
		- 제어는 커맨드 인터프리터로 전달되어야 함
	- File management
		- 파일 조작, 디렉토리 조작, 파일/디렉토리 속성
	- Device management
		- 장치->자원->관리(요청/반납)
	- Information maintenance
		- 시스템콜의 목적은 프로그램과 OS간 정보 전송임
		- 디버깅을 할때 좋음
		- 프로그램 실행 시간 정보 제공
		- 프로세스 정보에 대한 정보 키핑
	- Communication
		- 프로세스간 통신은, 메일박스를 통한 메세지교환/공유메모리로 함
		~~- 메세지교환  : 상대이름을 알아야함 (daemon이 쓰임)
		- ~~공유메모리 : 한 프로세스가 다른 프로세스가 공유한 메로리에 접근~~
		- ~~두개 다 흔해요.. 메세지 패싱쪽이 충돌도 없고 구현 쉬운데~~
		- ~~공유메모리가 빠르고 통신이 편리한 대신, 보호/동기화 이슈가 생김~~~~
	- Protection
		- 자원에 대한 접근 제어 방법 제공


# 2.5 Linkers/Loaders


- 프로그램은 이진실행파일(.out, .exe)의 형태임
- CPU에서 실행되려면, 메모리로 가져와서 프로세스로 배치해야됨
- 소스파일은 오브젝트 파일로 컴파일됨(물리메모리공간으로 불러올수 있는 형태)
- 그 다음, 링커가 얘를 다시 단일 이진실행 파일로 결합

- 로더 : 이진 파일을 CPU에서 돌릴 수 있는 공간인 '메모리'로 로드함
	- 링킹/로딩에 관련된 활동은 relocation이라고 함
		- 프로그램에 최종 주소 할당
		- 코드와 데이터를 이 주소에 맞게 조정
		- 따라서, 코드는 library function을 부르고, 변수에 접근 가능
- ./main : fork() 시스템콜을 사용해서 처음으로 프로그램을 돌리는 새로운 프로세스를 만드는 쉘

- 프로세스는 모든 library들이 실행파일에 link되고 메모리에 load되어야 함을 가정했음
- 대부분의 시스템은 프로그램이 load될 때 동적으로 시스템 라이브러리를 링크함

# 2.6 Why Applications are OS-specific?

- 왜 Application은 OS의 영향을 많이 받나요?
	- 각 OS는 고유의 system call 집합을 제공함
	- 특정 OS에서 컴파일된 Application은 다른 OS에서 실행 불가
	- System call은 OS가 제공하는 서비스의 일부임

- Application이 여러 OS에서 사용 가능하도록 하려면?
	- 1) 인터프리터 언어로 작성한다
		- 장점 : 인터프리터는 여러 OS에서 사용이 가능함
		- 단점: 성능 떨어지고, 기능이 제한됨
	- 2) 가상머신을 포함한 언어로 작성
		- 장점 : 어떤 java application이는 RTE 내에서 실행됨
		- 단점 : 인터프리터와 유사한 성능저하 이슈
	- 3) 표준 언어/API 사용한 후 컴파일
		- 단점 : 시간 걸림, 새 버전마다 포트 필요
		- 크로스-플랫폼 개발이 쉽지않음

# 2.7 OS Design and Implementation

- OS 설계 시 목표
	- 유저 목표
		- 시스템은 사용하기 편해야 하고, 배우기 쉬워야 하고, reliable하고, 안전하고, 빨라야함
	- 시스템 목표
		- 디자인,구현,유지하기 쉬워야함. 유연,효율,reliable,에러X

- OS 설계 시 기법과 정책
	- CPU 보호 (타이머 사용)
	- 프로그램 타입에 따라 다르게 (입출력을 많이 하는 애일수록 우선순위 높게 해서 CPU 마니쓰게)
	- 기법과 정책을 구분하는게 융통성 측면에서 좋음
	- 정책 : 시스템 오류를 확인
	- 기법 : 메시지 이용
	- 정책과 기법을 구분해야 유지보수가 편함

- OS의 구현 (디자인 후 구현)
	- 요즘은 거의다 C나 C++같은 고수준 언어 씀
	- 고급언어 쓰면?
		- 장) 코드가 빨리 써짐, 더 컴팩트함, 이해/디버그하기 쉬움, 다른 하드웨어로 포트하기 쉬움
		- 단) 속도 줄음, 용량을 많이 먹음 (현대에선 그닥 중요한 이슈는 아니죠?)

# 2.8 OS Structure


- 모듈화 개념 (기능을 모듈 단위로 분리 후 동작토록) 도입
	- 모듈 : 신중히 정의된 인터페이스와 함수를 가진 시스템의 잘 정의된 부분
	- main 함수에 전체 코드를 넣는 대신, 여러 함수로 로직을 분리

- Monolithic Structure
	- 너무 단순해서 구조가 없는거나 마찬가지
	- 단일 주소 공간에서 실행
	- 커널의 너무 많은 기능들이 단일 주소 공간으로 결합됨
	- 구조 단순, 구현/확장의 어려움
	- 성능이점 : 오버헤드 적음 ,커널 내 통신이라 빠름
	- 속도/효율성이 좋아서 여전히 잘 보이는 구조 (다른 구조를 결합해서 하이브리드루다가)

- Layered approach
	- loosely coupled system
		- 시스템이 개별적인 작은 요소들로 분리됨
		- 모든 요소들이 커널을 구성
		- 장) 하나를 바꾸면 거기에만 영향을 미쳐서 다루기 편리함
		- 여러 계층으로 구현된다는게 ..
		- 상위 계층이 하위계층의 연산을 호출함
		- 하위 계층은 상위 계층에서 호출되는 데이터/펑션으로 구성
	- 장) 구현과 디버깅이 간단 (다른 부분을 신경 안쓰니까, 에러가발생한 곳의 문제)
	- 단) 적절한 계층별 기능 정의가 어렵, 전체적 성능 저하 (여러 계층으 ㄹ거쳐야 함)
		- 해결) 계층을 줄이고 층당 기능을 늘림

- Microkernel
	- 커널이 너무 커지고 관리하기 어려윔..
	- 마이크로커널 접근 방식으로 커널을 모듈화
	- 작은 커널 : 중요하지 않은 모든 요소들을 커널에서 제거
		- 별도의 주소공간에 존재하는 유저레벨 프그램으로 구현
	- 통신 기능 외에, 최소한의 프로세스/메모리 관리기능 제공
	- 클라이언트 프로그램과 서비스 간 연결 제공 (메시지 패싱)
		- 직접통신 아닙니다
	- 장) OS 확장이 쉬움, 커널 수정이 불필요해서.. 보안/신뢰성 제공
	- 단) 시스템 부하 성능문제, 메시지가 독립된 주소 공간, 프로세스간스위치가 성장장애

- Module
	- UNIX의 현대 구현에서 많이 씀
	- LKM : 커널은 핵심 요소들을 가지며 ,부트/런타임시 추가서비스들을 모듈로 구현
	- 커널이 핵심 서비스(CPU스케쥴,메모리관리) 제공, 다른 서비스들은 커널 실행 동안 동적으로 구현
	- Layerd system과 유사 : 각 커널 영역이 정의되어 있음. 계층보단 유연
	- 계층시스템보단 효율적 (메세지 패싱이 없으니까)

- Hybird (대세)
	- 여러개를 잘 짬뽕해서 결합시킴
